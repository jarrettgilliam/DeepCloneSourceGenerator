namespace DeepClone.SourceGenerator;

using System;
using System.Threading;
using DeepClone.SourceGenerator.ExtensionMethods;
using DeepClone.SourceGenerator.Interfaces;
using DeepClone.SourceGenerator.Models;
using DeepClone.SourceGenerator.Services;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
internal class DeepCloneSourceGenerator : IIncrementalGenerator
{
    private ISourceCodeService SourceCode { get; } = new SourceCodeService();

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(this.GenerateDeepCloneableAttribute);

        IncrementalValuesProvider<DeepCloneTypeInfo> deepCloneTypesProvider =
            context.SyntaxProvider.CreateSyntaxProvider(
                    this.IsDeepCloneableType,
                    this.GetDeepCloneTypeInfo)
                .WhereNotNull();

        // TODO: Recursively loop over property types to find more types to add a DeepClone() function to

        context.RegisterSourceOutput(deepCloneTypesProvider, this.Execute);
    }

    private void GenerateDeepCloneableAttribute(IncrementalGeneratorPostInitializationContext context)
    {
        context.AddSource(
            $"{this.SourceCode.DeepCloneableAttributeName}.g.cs",
            this.SourceCode.DeepCloneableAttributeDefinition);
    }

    private bool IsDeepCloneableType(SyntaxNode syntaxNode, CancellationToken cancellationToken) =>
        syntaxNode is TypeDeclarationSyntax typeSyntax &&
        typeSyntax.Modifiers.Any(SyntaxKind.PartialKeyword) &&
        !typeSyntax.Modifiers.Any(SyntaxKind.StaticKeyword) &&
        typeSyntax.AttributeLists.ContainsAttribute(this.SourceCode.DeepCloneableAttributeShortName);

    private DeepCloneTypeInfo? GetDeepCloneTypeInfo(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        if (context.Node is not ClassDeclarationSyntax candidate ||
            context.SemanticModel.GetDeclaredSymbol(candidate, cancellationToken) is not { } symbol)
        {
            return null;
        }

        // TODO: Do more filter checking

        return new DeepCloneTypeInfo(
            symbol.ContainingNamespace.ToDisplayString(),
            symbol.Name,
            // TODO: Get property info
            Array.Empty<DeepClonePropertyInfo>());
    }

    private void Execute(SourceProductionContext context, DeepCloneTypeInfo typeInfo)
    {
        // TODO: Implement `DeepClone()` method
        context.AddSource($"{typeInfo.ClassName}.g.cs",
            $$"""
            // <auto-generated/>
            namespace {{typeInfo.ClassNamespace}};
            public partial class {{typeInfo.ClassName}}
            {
            }
            """);
    }
}