namespace DeepClone.SourceGenerator;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using DeepClone.SourceGenerator.ExtensionMethods;
using DeepClone.SourceGenerator.Interfaces;
using DeepClone.SourceGenerator.Models;
using DeepClone.SourceGenerator.Services;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
internal class DeepCloneSourceGenerator : IIncrementalGenerator
{
    private ISourceCodeService SourceCode { get; } = new SourceCodeService();

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(this.GenerateDeepCloneableAttribute);

        IncrementalValuesProvider<DeepCloneTypeInfo> deepCloneTypesProvider =
            context.SyntaxProvider.CreateSyntaxProvider(
                    this.IsDeepCloneableType,
                    this.GetTypeInfo)
                .WhereNotNull();

        // TODO: Recursively loop over property types to find more types to add a DeepClone() function to

        context.RegisterSourceOutput(deepCloneTypesProvider, this.GenerateDeepClone);
    }

    private void GenerateDeepCloneableAttribute(IncrementalGeneratorPostInitializationContext context)
    {
        context.AddSource(
            $"{this.SourceCode.DeepCloneableAttributeName}.g.cs",
            this.SourceCode.DeepCloneableAttributeDefinition);
    }

    private bool IsDeepCloneableType(SyntaxNode syntaxNode, CancellationToken cancellationToken) =>
        syntaxNode is TypeDeclarationSyntax typeSyntax &&
        typeSyntax.Modifiers.Any(SyntaxKind.PartialKeyword) &&
        !typeSyntax.Modifiers.Any(SyntaxKind.StaticKeyword) &&
        typeSyntax.AttributeLists.ContainsAttribute(
            this.SourceCode.DeepCloneableAttributeShortName,
            this.SourceCode.BaseNamespace);

    private DeepCloneTypeInfo? GetTypeInfo(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        if (context.Node is not ClassDeclarationSyntax candidate ||
            context.SemanticModel.GetDeclaredSymbol(candidate, cancellationToken) is not { } symbol)
        {
            return null;
        }

        // TODO: Do more filter checking

        return new DeepCloneTypeInfo(
            symbol.ContainingNamespace.ToDisplayString(),
            symbol.Name,
            this.GetPropertyInfos(symbol));
    }

    private IEnumerable<DeepClonePropertyInfo> GetPropertyInfos(
        INamedTypeSymbol symbol) =>
        symbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Select(property => new DeepClonePropertyInfo(property.Name));

    private void GenerateDeepClone(SourceProductionContext context, DeepCloneTypeInfo typeInfo)
    {
        // TODO: Implement `DeepClone()` method
        context.AddSource($"{typeInfo.ClassName}.g.cs",
            $$"""
            // <auto-generated/>
            namespace {{typeInfo.ClassNamespace}};

            public partial class {{typeInfo.ClassName}}
            {
                {{this.SourceCode.GeneratedCodeAttributeUsage}}
                public {{typeInfo.ClassName}} DeepClone() =>
                    new {{typeInfo.ClassName}}
                    {
                        {{this.GeneratePropertyInitializers(typeInfo.Properties)}}
                    };
            }
            """);
    }

    private string GeneratePropertyInitializers(
        IEnumerable<DeepClonePropertyInfo> deepClonePropertyInfos)
    {
        string propertyInitializers = string.Join(
           $"{Environment.NewLine}            ",
            deepClonePropertyInfos.Select(
                property => $"{property.PropertyName} = this.{property.PropertyName},"));

        return propertyInitializers;
    }
}